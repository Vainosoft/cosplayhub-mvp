{
  "workflow": {
    "name": "Admin ‚Äì Telegram Router",
    "description": "Admin/support bot @CosplayHubContMan_bot for content sources (/addsource) and manual review (/review)",
    "bot_username": "@CosplayHubContMan_bot",
    "admin_chat": "<ADMIN_CHAT_ID>",
    "branches": {
      "/addsource": "AI-assisted source onboarding and config update",
      "/review": "Fetch one ready_for_review content_item and show card in admin chat (no buttons yet)"
    },
    "nodes": [
      {
        "id": "telegram_trigger_admin",
        "name": "Telegram Trigger",
        "type": "telegramTrigger",
        "config": {
          "credential": "Telegram account (admin bot)",
          "bot_username": "@CosplayHubContMan_bot",
          "triggerOn": "Message",
          "restrictToChatIds": ["<ADMIN_CHAT_ID>"],
          "downloadFiles": false
        },
        "outputs": ["parse_command", "is_review_command"]
      },

      {
        "branch": "/addsource",
        "id": "parse_command",
        "name": "Parse Command",
        "type": "code",
        "language": "JavaScript",
        "description": "Extract /addsource <url> from admin chat messages. Filters out all other messages.",
        "code": [
          "// Input: Telegram Trigger update (message or edited_message)",
          "// Output items only for /addsource <url> commands.",
          "return items",
          "  .map(item => {",
          "    const msg = item.json.message || item.json.edited_message || null;",
          "    if (!msg) return null;",
          "    const text = (msg.text || '').trim();",
          "    const chat = msg.chat || {};",
          "    const from = msg.from || {};",
          "    if (!text.toLowerCase().startsWith('/addsource')) return null;",
          "    const parts = text.split(/\\s+/);",
          "    const url = parts[1] || '';",
          "    return {",
          "      json: {",
          "        raw_text: text,",
          "        source_url: url,",
          "        chat_id: chat.id,",
          "        chat_title: chat.title || chat.username || '',",
          "        user_id: from.id,",
          "        user_name: from.username || `${from.first_name || ''} ${from.last_name || ''}`.trim()",
          "      }",
          "    };",
          "  })",
          "  .filter(item => item !== null);"
        ],
        "outputs": ["build_source_draft"]
      },
      {
        "branch": "/addsource",
        "id": "build_source_draft",
        "name": "Build Source Draft",
        "type": "code",
        "language": "JavaScript",
        "description": "Generate source_key and default config for new RSS source.",
        "code": [
          "function makeSourceKey(url) {",
          "  let u = url.trim().toLowerCase();",
          "  u = u.replace(/^https?:\\/\\//, '');",
          "  u = u.replace(/\\/+$\\/, '');",
          "  const parts = u.split('\\/');",
          "  const domain = parts[0] || '';",
          "  const firstPath = parts[1] || '';",
          "  let key = domain;",
          "  if (firstPath) key += '-' + firstPath;",
          "  key = key.replace(/[^a-z0-9]+/g, '_');",
          "  key = key.replace(/_+/g, '_').replace(/^_+|_+$/g, '');",
          "  if (!key) key = 'source_' + Date.now();",
          "  return key;",
          "}",
          "",
          "return items.map(item => {",
          "  const data = item.json;",
          "  const url = (data.source_url || '').trim();",
          "  const sourceKey = makeSourceKey(url);",
          "  const defaultName = `Source ${sourceKey}`;",
          "  return {",
          "    json: {",
          "      raw_text: data.raw_text,",
          "      chat_id: data.chat_id,",
          "      chat_title: data.chat_title,",
          "      user_id: data.user_id,",
          "      user_name: data.user_name,",
          "      source_url: url,",
          "      source_key: sourceKey,",
          "      name: defaultName,",
          "      type: 'rss',",
          "      default_language: 'en',",
          "      default_geo_tags: ['global'],",
          "      default_topic_tags: [],",
          "      fetch_interval_minutes: 60,",
          "      is_active: false,",
          "      content_type: 'news'",
          "    }",
          "  };",
          "});"
        ],
        "outputs": ["upsert_source"]
      },
      {
        "branch": "/addsource",
        "id": "upsert_source",
        "name": "Upsert Source",
        "type": "postgres",
        "description": "INSERT ... ON CONFLICT (source_key) DO UPDATE for table public.source.",
        "sql": [
          "INSERT INTO public.source",
          "(",
          "    source_key,",
          "    name,",
          "    type,",
          "    url,",
          "    default_language,",
          "    fetch_interval_minutes,",
          "    is_active,",
          "    content_type",
          ")",
          "VALUES",
          "(",
          "    '{{{{$json[\"source_key\"]}}}}',",
          "    '{{{{$json[\"name\"]}}}}',",
          "    '{{{{$json[\"type\"]}}}}',",
          "    '{{{{$json[\"source_url\"]}}}}',",
          "    '{{{{$json[\"default_language\"]}}}}',",
          "    {{{{$json[\"fetch_interval_minutes\"]}}}},",
          "    {{{{$json[\"is_active\"]}}}},",
          "    '{{{{$json[\"content_type\"]}}}}'",
          ")",
          "ON CONFLICT (source_key)",
          "DO UPDATE SET",
          "    name = EXCLUDED.name,",
          "    type = EXCLUDED.type,",
          "    url = EXCLUDED.url,",
          "    default_language = EXCLUDED.default_language,",
          "    fetch_interval_minutes = EXCLUDED.fetch_interval_minutes,",
          "    is_active = EXCLUDED.is_active,",
          "    content_type = EXCLUDED.content_type",
          "RETURNING id, source_key, name;"
        ],
        "outputs": ["load_source_for_ai"]
      },
      {
        "branch": "/addsource",
        "id": "load_source_for_ai",
        "name": "Load Source For AI",
        "type": "postgres",
        "description": "Load current source row by source_key for AI analysis.",
        "sql": [
          "SELECT",
          "  id,",
          "  source_key,",
          "  name,",
          "  type,",
          "  url,",
          "  default_language,",
          "  fetch_interval_minutes,",
          "  is_active,",
          "  content_type",
          "FROM public.source",
          "WHERE source_key = '{{{{$item(0).$node[\"Upsert Source\"].json[\"source_key\"]}}}}';"
        ],
        "outputs": ["rss_read_ai_preview"]
      },
      {
        "branch": "/addsource",
        "id": "rss_read_ai_preview",
        "name": "RSS Read (AI Source Preview)",
        "type": "rssFeedRead",
        "description": "Reads a few items from source.url to show AI examples.",
        "config": {
          "url_expression": "{{$json[\"url\"]}}",
          "options": {
            "limit": 5
          }
        },
        "outputs": ["build_ai_payload"]
      },
      {
        "branch": "/addsource",
        "id": "build_ai_payload",
        "name": "Build AI Payload",
        "type": "code",
        "language": "JavaScript",
        "description": "Combine source row and sample RSS items into single JSON payload for LLM.",
        "code": [
          "const source = $item(0).$node[\"Load Source For AI\"].json;",
          "if (!source) return [];",
          "const maxSamples = 5;",
          "const samples = items.slice(0, maxSamples).map(item => {",
          "  const rss = item.json;",
          "  return {",
          "    title: rss.title || '',",
          "    description: rss.contentSnippet || rss.description || '',",
          "    link: rss.link || '',",
          "    pubDate: rss.pubDate || rss.isoDate || null,",
          "  };",
          "});",
          "return [",
          "  {",
          "    json: {",
          "      source_id: source.id,",
          "      source_key: source.source_key,",
          "      url: source.url,",
          "      current_config: {",
          "        name: source.name,",
          "        default_language: source.default_language,",
          "        content_type: source.content_type,",
          "        fetch_interval_minutes: source.fetch_interval_minutes,",
          "        is_active: source.is_active,",
          "      },",
          "      samples,",
          "    },",
          "  },",
          "];"
        ],
        "outputs": ["basic_llm_chain"]
      },
      {
        "branch": "/addsource",
        "id": "openai_chat_model",
        "name": "OpenAI Chat Model",
        "type": "openAiChatModel",
        "description": "Reusable chat model node (e.g. gpt-4.1-mini)."
      },
      {
        "branch": "/addsource",
        "id": "basic_llm_chain",
        "name": "Basic LLM Chain",
        "type": "basicLlmChain",
        "description": "Calls OpenAI Chat Model with system prompt and payload from Build AI Payload.",
        "config": {
          "model_node": "OpenAI Chat Model",
          "source_for_prompt": "Define below",
          "prompt_expression": [
            "Here is the source payload in JSON:",
            "",
            "{{ JSON.stringify($json) }}"
          ],
          "chat_messages": [
            {
              "role": "system",
              "message": [
                "You are a content classification assistant for a cosplay news hub for Finland and the Nordics.",
                "You receive JSON describing an RSS source and a few of its recent posts.",
                "Your task is to propose a clean, structured configuration for this source.",
                "",
                "Return ONLY valid JSON, no explanations, no markdown.",
                "",
                "Fields:",
                "- name: short human-readable source name (string)",
                "- default_language: two-letter code, one of [\"en\",\"fi\",\"sv\",\"no\",\"da\",\"is\",\"ja\",\"other\"]",
                "- default_geo_tags: array of strings from [\"global\",\"fi\",\"se\",\"no\",\"dk\",\"is\",\"nordics\"]",
                "- default_topic_tags: array of strings from controlled list",
                "- content_type: one of [\"tutorial\",\"news\",\"event\",\"profile\",\"announcement\",\"other\"]",
                "- fetch_interval_minutes: one of [15,30,60,120,360]",
                "- is_active: boolean"
              ]
            }
          ]
        },
        "outputs": ["parse_ai_config"]
      },
      {
        "branch": "/addsource",
        "id": "parse_ai_config",
        "name": "Parse AI Config",
        "type": "code",
        "language": "JavaScript",
        "description": "Parse JSON string from LLM and merge with source identifiers.",
        "code": [
          "const sourcePayload = $item(0).$node[\"Build AI Payload\"].json;",
          "",
          "return items.map(item => {",
          "  const text = item.json.text || '';",
          "  let aiConfig;",
          "  try {",
          "    aiConfig = JSON.parse(text);",
          "  } catch (e) {",
          "    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON –æ—Ç AI: ' + e.message + '\\n–û—Ç–≤–µ—Ç: ' + text);",
          "  }",
          "  const name = aiConfig.name || sourcePayload.current_config?.name || sourcePayload.source_key;",
          "  const defaultLanguage = aiConfig.default_language || sourcePayload.current_config?.default_language || 'en';",
          "  const defaultGeoTags = Array.isArray(aiConfig.default_geo_tags) ? aiConfig.default_geo_tags : ['global'];",
          "  const defaultTopicTags = Array.isArray(aiConfig.default_topic_tags) ? aiConfig.default_topic_tags : [];",
          "  const contentType = aiConfig.content_type || sourcePayload.current_config?.content_type || 'news';",
          "  const fetchInterval = aiConfig.fetch_interval_minutes || sourcePayload.current_config?.fetch_interval_minutes || 60;",
          "  const isActive = typeof aiConfig.is_active === 'boolean' ? aiConfig.is_active : false;",
          "  return {",
          "    json: {",
          "      source_id: sourcePayload.source_id,",
          "      source_key: sourcePayload.source_key,",
          "      url: sourcePayload.url,",
          "      suggested: {",
          "        name,",
          "        default_language: defaultLanguage,",
          "        default_geo_tags: defaultGeoTags,",
          "        default_topic_tags: defaultTopicTags,",
          "        content_type: contentType,",
          "        fetch_interval_minutes: fetchInterval,",
          "        is_active: isActive,",
          "      },",
          "      raw_ai_response: text,",
          "    },",
          "  };",
          "});"
        ],
        "outputs": ["apply_ai_config"]
      },
      {
        "branch": "/addsource",
        "id": "apply_ai_config",
        "name": "Apply AI Config",
        "type": "postgres",
        "description": "Update public.source with fields from suggested AI config.",
        "sql": [
          "UPDATE public.source",
          "SET",
          "  name = '{{{{$json[\"suggested\"][\"name\"]}}}}',",
          "  default_language = '{{{{$json[\"suggested\"][\"default_language\"]}}}}',",
          "  fetch_interval_minutes = {{{{$json[\"suggested\"][\"fetch_interval_minutes\"]}}}},",
          "  is_active = {{{{$json[\"suggested\"][\"is_active\"]}}}},",
          "  content_type = '{{{{$json[\"suggested\"][\"content_type\"]}}}}'",
          "WHERE source_key = '{{{{$json[\"source_key\"]}}}}'",
          "RETURNING",
          "  id,",
          "  source_key,",
          "  name,",
          "  default_language,",
          "  fetch_interval_minutes,",
          "  is_active,",
          "  content_type;"
        ],
        "outputs": ["send_ai_config_summary"]
      },
      {
        "branch": "/addsource",
        "id": "send_ai_config_summary",
        "name": "Send AI Config Summary",
        "type": "telegramSendMessage",
        "description": "Reply to admin chat with applied AI config for source.",
        "config": {
          "chat_id_expression": "{{$item(0).$node[\"Build Source Draft\"].json[\"chat_id\"]}}",
          "parse_mode": "HTML",
          "text_expression": [
            "‚úÖ AI config applied for source\n\n",
            "ID: {{$json[\"id\"]}}\n",
            "Key: {{$json[\"source_key\"]}}\n",
            "Name: {{$json[\"name\"]}}\n\n",
            "Language: {{$json[\"default_language\"]}}\n",
            "Type: {{$json[\"content_type\"]}}\n",
            "Active: {{$json[\"is_active\"] ? 'true' : 'false'}}\n\n",
            "AI geo tags (not saved yet):\n",
            "{{ ($item(0).$node[\"Parse AI Config\"].json[\"suggested\"][\"default_geo_tags\"] || []).join(', ') }}\n\n",
            "AI topic tags (not saved yet):\n",
            "{{ ($item(0).$node[\"Parse AI Config\"].json[\"suggested\"][\"default_topic_tags\"] || []).join(', ') }}\n\n",
            "URL: {{$item(0).$node[\"Parse AI Config\"].json[\"url\"]}}"
          ]
        }
      },

      {
        "branch": "/review",
        "id": "is_review_command",
        "name": "Is /review command",
        "type": "if",
        "description": "Split admin flow: /review vs all other messages.",
        "condition": {
          "left_expression": "{{$json[\"message\"][\"text\"] || ''}}",
          "operation": "starts_with",
          "right_value": "/review"
        },
        "outputs": {
          "true": ["get_item_for_review"],
          "false": ["parse_command"]
        }
      },
      {
        "branch": "/review",
        "id": "get_item_for_review",
        "name": "Get item for review",
        "type": "postgres",
        "description": "Select single latest content_item with status='ready_for_review' for manual moderation.",
        "sql": [
          "SELECT",
          "  ci.id,",
          "  ci.title,",
          "  ci.original_url,",
          "  ci.status,",
          "  ci.content_type,",
          "  ci.published_at,",
          "  ci.updated_at,",
          "  s.name AS source_name,",
          "  s.source_key",
          "FROM public.content_item AS ci",
          "LEFT JOIN public.source AS s ON s.id = ci.source_id",
          "WHERE ci.status = 'ready_for_review'",
          "ORDER BY ci.updated_at DESC",
          "LIMIT 1;"
        ],
        "outputs": ["send_review_card"]
      },
      {
        "branch": "/review",
        "id": "send_review_card",
        "name": "Send review card",
        "type": "telegramSendMessage",
        "description": "Send one content_item card to admin chat for review (no buttons yet).",
        "config": {
          "chat_id_expression": "{{$item(0).$node[\"Telegram Trigger\"].json[\"message\"][\"chat\"][\"id\"]}}",
          "parse_mode": "HTML",
          "text_expression": [
            "üé≠ {{$json[\"title\"] || '(no title)'}}\n\n",
            "üì° Source: {{$json[\"source_name\"] || $json[\"source_key\"] || 'unknown'}}\n",
            "üìÖ Published: {{$json[\"published_at\"] || '‚Äî'}}\n\n",
            "üîó {{$json[\"original_url\"] || 'No original URL'}}\n\n",
            "Status: {{$json[\"status\"]}} | Type: {{$json[\"content_type\"]}}\n",
            "ID: {{$json[\"id\"]}}"
          ]
        }
      }
    ],
    "edges": [
      ["telegram_trigger_admin", "parse_command"],
      ["telegram_trigger_admin", "is_review_command"],
      ["parse_command", "build_source_draft"],
      ["build_source_draft", "upsert_source"],
      ["upsert_source", "load_source_for_ai"],
      ["load_source_for_ai", "rss_read_ai_preview"],
      ["rss_read_ai_preview", "build_ai_payload"],
      ["build_ai_payload", "basic_llm_chain"],
      ["basic_llm_chain", "parse_ai_config"],
      ["parse_ai_config", "apply_ai_config"],
      ["apply_ai_config", "send_ai_config_summary"],
      ["is_review_command:true", "get_item_for_review"],
      ["is_review_command:false", "parse_command"],
      ["get_item_for_review", "send_review_card"]
    ]
  }
}
